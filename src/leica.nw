\documentclass[a4paper,10pt]{article}
\usepackage[unicode,verbose]{hyperref}
\usepackage{amsmath,amssymb,amsthm} \usepackage{pb-diagram}
\usepackage{ucs}
\usepackage{noweb}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{cmap}
\usepackage[pdftex]{graphicx}

\begin{document}
\pagestyle{noweb}

@ \paragraph{Введение.} Год назад, после недолгого изучения Python'а и
Common Lisp'а, я взялся за Clojure. Примерно в то же время я открыл
для себя местный файлообменный сайт, ныне опустившийся до непотребного
в плане рекламы состояния, но все еще приносящий пользу, благо на нем
обитает немало народу со всего дальнего востока. На этом сайте любой
желающий может опубликовать свое сообщение~--- набор из картинок,
текста описания и ссылок на залитые на файлообменник файлы. Часто
среди опубликованного на сайте попадается действительно стоящий
контент. Недоразвитость приморского интернета вносит свою долю~---
днем моего безлимита хватает только на веб-страницы, так что торренты
работают только ночью, местный же файлообменник работает всегда (хотя
и ложится частенько).

Ubuntu~--- моя домашняя система. В сообществе файлообменника есть
программирующие люди, но ориентируются они в основном на пользователей
Windows (есть на то причина~--- согласно статистике, процент
пользователей Linux~--- это процент всех
пользователей). Соответственно, под линукс программ нет (точнее, есть
скрипты, но они страшны как смертный грех), а качать ручками не мой
метод.

Я взялся написать качалку. Сперва попробовал написать её на Common
Lisp~--- не получилось (я плохо его знал). Потом я попробовал
написать её на Python. Получилось. Но программа была многопоточная,
а питон и многопоточность~--- вещи не лучшим образом подходящие друг
другу. Внутренняя структура походила на многоэтажное здание,
построенное из костылей.

Я бросил Python и взялся переписать программу на Clojure. Получилось
не с первого раза, но процесс и результат меня порадовали: при всей
многопоточности работа с состоянием так же проста, как в обычных,
однопоточных императивных программах~--- происходит практически «не
  задумываясь», одним словом Clojure~--- отличный выбор для
многопоточных сетевых приложений.

Далее я расскажу как я написал многопоточное приложение на Clojure на
примере моей качалки.

@ \paragraph{Дизайн многопоточной программы.} В отличие от простых,
последовательных программ, работающих в одном потоке, сконструировать
многопоточную программу куда сложнее~--- из-за большого количества
потенциальных взаимодействий между её частями. Но если следовать
следующим простым правилам, задача сильно упрощается.

1. {\emНеформальная спецификация}. Первым делом нужно определить~---
что же программа должна делать?

2. {\emКомпоненты.} Необходимо перечислить все формы конкурентной
активности~--- каждая из них становится компонентом (например,
агентом). Далее следует нарисовать блочную диаграмму системы, в
которой будут показаны все экземпляры компонентов.

3. {\emПротокол сообщений.} Решить какие сообщения будут посылать
компоненты и спроектировать протоколы соообщений между
ними. Нарисовать диаграмму компонентов со всеми протоколами сообщений.

4. {\emДиаграммы состояний.} Для каждого конкурентного компонента
нужно нарисовать диаграмму состояний и проверить, что в каждом
состоянии компонент получает и посылает правильные сообщения и
выполняет правильные действия.

5. {\emЗакодировать. Оттестировать. Повторить.}


@ \paragraph{Неформальная спецификация.} У нас есть несколько ссылок
на страницы файлообменника, на котором лежит несколько файлов. Файлы
нужно скачать, причем их можно качать в несколько потоков. По ходу
могут возникнуть проблемы~--- на файлообменнике может не оказаться
файла, загрузка может оборваться, на диске может кончиться место~---
при обрыве загрузка должна возобновляться. Программа будет работать в
пакетном режиме~--- все требуемые для загрузки адреса.

%% # Переменные в Clojure

%% Clojure — особенный императивный язык. В отличие от подавляющего
%% большинства языков программирования, в которых есть только один способ
%% работы с состоянием — старые добрые переменные, в Clojure их как минимум
%% 4, из-за специфичного подхода *программной транзакционной памяти*
%% (Software Transactional Memory, STM).

%% Подход к состоянию в Clojure довольно прост — он основывается на
%% четком разграничении **значения**, **состояния** и **идентичности**,
%% которые во многих языках объединены в одну сущность:

%% **Значение** (*value*) — нечто неизменяемое, или совокупность
%% неизменяемых величин (например число 3 — оно, как говорится, и в
%% Африке 3 — в математическом, вневременном смысле; все тройки
%% одинаковы, в том смысле, что существует только *одна* "тройка").

%% **Идентичность** (*identity*) — сущность, которую мы ассоциируем с
%% последовательностью значений (состояний) во времени. Даже если 2
%% идентичности имеют одинаковое значение (или одно и то же значение —
%% тут никакой разницы), они не будут равны друг другу.

%% **Состояние** (*value*) — значение идентичности в некоторый момент
%% времени.

%% ————— картинка про идентичность значение и время

%% Идентичностями (т.е. изменяемыми объектами) в Clojure являются
%% *переменные* и *ссылки* (references), всего их 4 вида, каждая для
%% своих целей:

%% **Переменные** (*vars*) — могут изменяться только внутри одного
%% единственного потока, поэтому они используются как глобальные
%% переменные — к ним привязываются функции, константы; из-за
%% динамической привязки отлично подходят для разного рода
%% аспектно-ориентированного программирования.

%% **Атомы** (*atoms*) — переменные, доступные для чтения и изменения изо
%% всех потоков; изменяются атомарно, по-отдельности, кажлый атом в своей
%% транзакции. Ипользуются как старые добрые переменные в обычных языках.

%% **Ссылки** (*refs*) — как атомы, только изменяются внутри явно
%%   обозначенной программистом транзакции, поэтому используются для
%%   одновременного изменения сразу множества ссылок.

%% **Агенты** (*agents*) — переменные, доступные изо всех потоков, для
%%   изменения которых нужно отправить им *сообщение*, состоящее из
%%   функции с аргументами. После отправки сообщения агенту программа
%%   продолжает свою работу; изменение агента (вычисление функции
%%   сообщения) происходит в отдельном потоке, после чего агент принимает
%%   значение результата вычисления сообщения. Агенту можно послать сразу
%%   несколько сообщений — они сохранятся в очереди сообщений и будут
%%   обработаны последовательно. До тех пор, пока не будет вычислено
%%   сообщение, агент сохраняет свое прежнее значение.

%% # Агенты

%% Стиль программирования агентов Clojure в миру зовется *Asynchronous
%% Message-Passing Concurrency. Здесь *asynchronous* означает отсутствие
%% необходимости дожидаться изменения агента после отправки сообщения.

%% Агенты используются как основные "рабочие лошадки" в Clojure. В
%% отличие от ссылок и атомов, изменять которые можно только *чистыми*
%% функциями (точнее, очень рекомендуется — из-за отката и повтора
%% транзакций побочные эффекты могут наделать много дел) сообщения
%% агентов, как правило — функции с побочными эффектами.

%% ## Отправка сообщений

%% Агенту можно отправить сообщение двумя способами:

%%     #!clojure
%%     (send agent function args)

%% — для "быстрых" или "процессороёмких", обычно без побочных эффектов,
%% сообщений. Такие сообщения будут выполняться на ограниченном, в
%% зависимости от количества ядер процессора, количестве потоков.

%% Другой вариант для "долгоиграющих", обычно с обильным вводом-выводом,
%% сообщений:

%%     #!clojure
%%     (send-off agent function args)

%% — такие будут выполняться на большем количестве потоков, чем сообщения
%% отправленные `send`'ом.

%% Состояние агента можно узнать в любое время — для этого не надо ждать
%% окончания обработки отправленного ему сообщения:

%%     #!clojure
%%     (deref agent)
%%     ;; или
%%     @agent

%% .............
    
%% ## Ошибки агентов

%% Если во время обработки сообщения возникает ошибка (возникает
%% исключение, throw exception) — она сохраняется в агенте, ошибки агента
%% можно увидеть вызвав:

%%     #!clojure
%%     (agent-errors agent)

%% При этом агент становится недоступным для сообщений до тех пор, пока
%% не будет очищен от ошибок функцией:

%%     #!clojure
%%     (clear-agent-errors agent)

%% ## Корректность агентов


\end{document}
