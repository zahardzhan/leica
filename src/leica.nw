\documentclass[a4paper,10pt]{article}
\usepackage[unicode,verbose]{hyperref}
\usepackage{verbatim}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{pb-diagram}
\usepackage{ucs}
\usepackage{noweb}
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{cmap}
\usepackage[pdftex]{graphicx}

\begin{document}
\pagestyle{noweb}

@ \paragraph{Введение.} Год назад, после недолгого изучения Python и
Common Lisp, я взялся за Clojure. Примерно в то же время я открыл для
себя местный файлообменный сайт, ныне опустившийся до непотребного в
плане рекламы состояния, но все еще приносящий пользу, благо на нем
обитает немало народу со всего дальнего востока. На этом сайте любой
желающий может опубликовать свое сообщение~--- набор из картинок,
текста описания и ссылок на залитые на файлообменник файлы. Часто
среди опубликованного на сайте попадается действительно стоящий
контент. И в большинстве случаев это вовсе не один файл, а добрая
пачка на несколько гигабайт. Естественно, ставить закачки в очередь
ручками и караулить не сломалось ли чего по ходу дела~--- не мой
метод. И конечно же, закачек должно быть много и идти они должны
одновременно.

Ubuntu~--- моя домашняя система. В сообществе файлообменника есть
программирующие люди, но они ориентируются в основном на пользователей
Windows (на то есть веская причина~--- согласно статистике, процент
пользователей Linux~--- это 1 процент от всех
пользователей). Соответственно, под линукс программ нет (точнее, есть
скрипты некоторых пользователей, но они страшны как смертный грех), а
тот один единственный достойный менеджер закачек и по совместительству
плугин Фаерфокса (которым я не пользуюсь с тех пор как появился Хром)
слишком «общий» и не достаточно хорошо заточен под этот сайт.

Я взялся написать качалку. Сперва попробовал написать её на Common
Lisp~--- не получилось (я плохо его знал). Потом я попробовал
написать её на Python. Получилось. Но программа была многопоточная,
а питон и многопоточность~--- вещи не лучшим образом подходящие друг
другу. Внутренняя структура походила на многоэтажное здание,
построенное из костылей.

Я бросил Python и взялся переписать программу на Clojure. Получилось
не с первого раза, но процесс и результат меня порадовали: при всей
многопоточности работа с состоянием так же проста, как в обычных,
однопоточных императивных программах~--- происходит практически «не
  задумываясь», одним словом Clojure~--- отличный выбор для
многопоточных сетевых приложений.

Если быть чуть более честным, то эта конечная версия «Лейки», которую
я здесь описываю является плодом многократных переписываний и
всевозможных экспериментов над кодом, стилем и подходом к написанию
программ на Clojure. Эту программу я переписывал около семи раз в
течение года. Усилия, что я приложил к этому~--- хорошая цена за
полученный мною опыт. В результате каждой такой переписи я осваивал
тот или иной прием программирования. И изложенная ниже финальная
версия программы представляет собой предельно идиоматичный Clojure-код
который я сейчас способен написать.

Далее я расскажу как написать  приложение на Clojure на
примере моей качалки.

@ \paragraph{Дизайн конкурентной программы.} В отличие от простых,
последовательных программ, работающих в одном потоке, сконструировать
конкурентную программу куда сложнее~--- из-за большого количества
потенциальных взаимодействий между её частями, работающих в разных
потоках (что, собственно и является смыслом слова «конкурентный»). Но
если следовать следующим простым правилам, задача сильно упрощается.

\begin{enumerate}
\item \emph{Неформальная спецификация}. Первым делом нужно
  определить~--- что же программа должна делать?

\item \emph{Компоненты.} Необходимо перечислить все формы конкурентной
  активности~--- каждая из них становится компонентом (например,
  агентом). Далее следует нарисовать блочную диаграмму системы, в
  которой будут показаны все экземпляры компонентов.

\item \emph{Протокол сообщений.} Решить какие сообщения будут посылать
  компоненты и спроектировать протоколы соообщений между
  ними. Нарисовать диаграмму компонентов со всеми протоколами
  сообщений.

\item \emph{Диаграммы состояний.} Для каждого конкурентного компонента
  нужно нарисовать диаграмму состояний и проверить, что в каждом
  состоянии компонент получает и посылает правильные сообщения и
  выполняет правильные действия.

\item \emph{Закодировать и распланировать.} Закодировать систему на
  любимом языке программирования и выбрать любимый алгоритм
  планирования взаимодействий между компонентами.

\item \emph{Протестировать и повторять} до тех пор пока программа не
  станет работать так как от нее ожидается.
\end{enumerate}

@ \paragraph{Неформальная спецификация.} У нас есть текстовый файл
наполненный ссылками на страницы разнообразных файлообменных ресурсов
или ссылками непосредственно на файлы на этих ресурсах. Нам нужно
скачать эти файлы с файлообменников, причем их можно качать в
несколько потоков, в зависимости от возможностей, предоставляемых
конкретными сервисами. По ходу скачивания могут возникнуть
проблемы~--- на файлообменнике может не оказаться файла, загрузка
может оборваться, на диске может быть недостаточно места~--- при
обрыве загрузка должна возобновляться, если это возможно. Программа
консольная и будет работать в пакетном режиме, при этом во время её
работы в консоли будет отображаться полоса прогресса загрузки.

Но прежде чем перейти к деталям реализации я сделаю большое
отступление и расскажу о тонкостях работы с состоянием в Clojure.

@ \paragraph{Работа с состоянием в Clojure.} Clojure~--- особенный
императивный язык. В отличие от подавляющего большинства языков
программирования, в которых есть только один способ работы с
состоянием~--- старые добрые переменные, в Clojure их как минимум четыре,
из-за специфичного подхода \emph{программной транзакционной памяти}
(\emph{software transactional memory, STM}).

Подход к состоянию в Clojure довольно прост~--- он основывается на
четком разграничении \emph{значения}, \emph{состояния} и
\emph{идентичности}, которые во многих языках объединены в одну
сущность.

\begin{description}
\item[Значение (\emph{value})] Нечто неизменяемое, или совокупность
  неизменяемых величин. Например число 3~--- оно, как говорится, и в
  Африке 3~--- в математическом, вневременном смысле; все тройки
  одинаковы, в том смысле, что существует только \emph{одна}
  «тройка».

\item[Идентичность (\emph{identity})] Сущность, которую мы ассоциируем
  с последовательностью состояний во времени. Даже если 2 идентичности
  имеют одинаковое значение (или одно и то же значение~--- тут никакой
  разницы), они не будут равны друг другу.

\item[Состояние (\emph{value})] Значение идентичности в некоторый
  момент времени.
\end{description}

Идентичностями (т.е. изменяемыми объектами) в Clojure являются
\emph{переменные} (\emph{variables}) и \emph{ссылки}
(\emph{references}), всего их 4 вида, у каждый вид используется для
своих целей.

\begin{description}
\item[Переменные (\emph{variables})] могут изменяться только внутри одного
  единственного потока, поэтому они используются как глобальные
  переменные~--- к ним привязываются функции, макросы и просто
  значения; из-за динамической привязки отлично подходят для разного
  рода аспектно-ориентированного программирования.

\item[Атомы (\emph{atoms})] это переменные, доступные для чтения и
  изменения из всех потоков; изменяются атомарно, по-отдельности,
  кажлый атом в своей транзакции. Ипользуются как старые добрые
  переменные в обычных языках.

\item[Ссылки (\emph{references})] — как атомы, только изменяются внутри явно
  обозначенной программистом транзакции, поэтому используются для
  одновременного координированного группового изменения.

\item[Агенты (\emph{agents})] — переменные, доступные изо всех
  потоков, для изменения которых нужно отправить им \emph{сообщение},
  состоящее из функции с аргументами. После отправки сообщения агенту
  программа продолжает свою работу; изменение агента (вычисление
  функции сообщения) происходит в отдельном потоке, после чего агент
  принимает значение результата вычисления сообщения. Агенту можно
  послать сразу несколько сообщений, они сохранятся в очереди
  сообщений и будут обработаны последовательно. До тех пор, пока не
  будет вычислено сообщение, агент сохраняет свое прежнее значение.
\end{description}

Агенты~--- ключевые компоненты в этой программе, поэтому о них стоит
рассказать подробнее.

Стиль программирования агентов Clojure в миру зовется
\emph{asynchronous message-passing concurrency}. Здесь
\emph{asynchronous} означает отсутствие необходимости дожидаться
изменения агента после отправки ему сообщения.

Агенты используются как основные «рабочие лошадки». В отличие от
ссылок и атомов, изменять которые можно только «чистыми» функциями
(точнее, очень рекомендуется~--- из-за отката и повтора транзакций
побочные эффекты могут причинить неприятности) сообщения агентов, как
правило~--- функции с побочными эффектами.

Агенту можно отправить сообщение двумя способами. Первый~--- для
«быстрых» или процессороёмких, обычно без побочных эффектов,
сообщений. Такие сообщения будут выполняться на ограниченном, в
зависимости от количества ядер процессора, количестве потоков:

\begin{verbatim}
  (send agent function args)
\end{verbatim}

Другой вариант для «долгоиграющих», обычно с обильным вводом-выводом,
сообщений. Такие будут выполняться на большем количестве потоков, чем
сообщения отправленные [[send]]'ом.

\begin{verbatim}
  (send-off agent function args)
\end{verbatim}

Состояние агента можно узнать в любое время~--- для этого не надо
ждать окончания обработки отправленного ему сообщения:

\begin{verbatim}
  (deref agent)
  или
  @agent
\end{verbatim}
    
Если во время обработки сообщения возникает ошибка (исключение)~---
она сохраняется в агенте, ошибки агента можно увидеть вызвав функциию
[[agent-errors]]. При этом агент становится недоступным для сообщений
до тех пор, пока не будет очищен от ошибок функцией
[[clear-agent-errors]].

% TODO: *agent*

@ \paragraph{Компоненты.} В программе будет три взаимодействующих
компонента, каждый из которых представляет свой тип конкурентной
активности~--- многочисленные \emph{загрузки}, \emph{планировщик
  загрузок} и \emph{монитор прогресса} загрузок. Все эти компоненты
представлены агентами Clojure и работают одновременно, координируя
свои действия между собой.

\emph{Загрузки} это основные работники в этой программе. Эти агенты
управляют всем процессом загрузки файла, начиная от получения ссылки
со страницы с файлообменника и заканчивая собственно скачиванием
файла. Загрузки могут быть высокоуровневыми и по ходу своей работы они
могут создавать и управлять более низкоуровневыми загрузками. Загрузки
создаются конструктором [[make-download]]. Все наличествующие в
программе загрузки хранятся в глобальной переменной [[downloads*]]~---
это ссылка на множество загрузок.

Загрузки автономны, каждая из них имеет собственную программу и сама
управляет своими действиями, поэтому внешний интерфейс к ним весьма
прост; единственное, что можно сделать с загрузкой~--- отправить ей
сообщение запуска [[run]] и загрузка, в зависимости от ситуации в
которой она находится, выполнит действие предписанное ей её программой.

\emph{Планировщик загрузок} это агент который координирует совместную
работу загрузок друг с другом: он составляет планы, запускает загрузки
и следит за тем чтобы между ними не возникали конфликты из-за
ресурсов. Планировщик представлен глобальной переменной
[[download-scheduler*]]. 

Планировщик фактически является реактивным агентом, т.е. без
внутреннего состояния~— он работает с глобальным состоянием всей
программы). Ему можно послать сообщение [[schedule-downloads]] в ходе
обработки которого он определит загрузки которые нужно запустить, а
затем пошлет им сообщение запуска [[run]].

\emph{Монитор прогресса} это агент который отвечает за отображение
информации о работе программы. Он отрисовывает полосу прогресса в
консоли. Монитор представлен глобальной переменной
[[progress-monitor*]].

Монитор принимает сообщения от загрузок о начале слежения за
прогрессом загрузки [[begin-monitor-progress]], об обновлении
прогресса загрузки [[update-progress]] и о прекращении слежения за
прогрессом загрузки [[cease-monitor-progress]].

@ \paragraph{Загрузка.} Загрузка (\emph{downloads}) является агентом и
создается из соответствующего прототипа загрузки с помощью
конструктора [[make-download]] из строки \texttt{line} содержащей
ссылку на файлообменный ресурс. Конструктор [[make-download]] в
качестве опциональных ключей принимает \emph{программу загрузки}
{\ttfamily:program}, каталог в который должны скачиваться файлы
{\ttfamily:path} и имя загрузки {\ttfamily:name}. Каждой новой
загрузке автоматически присваивается её порядковый номер
{\ttfamily:precedence} и она добавляется ко множеству уже созданных
загрузок [[downloads*]] чтобы планировщик загрузок мог обеспечить их
корректную работу друг с другом.

{\emТело загрузки} является хэшем (здесь и далее термин «хэш»
обозначает базовую для Clojure структуру данных \emph{hash-map})
который представляет текущее состояние агента загрузки. Разные
загрузки создаются из разных прототипов и с разными телами~--- в
зависимости от того какие функции они выполняют.

{\emТип загрузки} это метка хранящаяся в ключе \texttt{:type}
метаданных тела загрузки. Свой тип (и соответственно прототип)
загрузки определяются для каждого отдельного сетевого файлообменного
сервиса с которым работают загрузки.

{\emПрограмма загрузки} это функция, которая определяет каждое
следующее \emph{действие} загрузочного агента, она полностью
контролирует его поведение; на вход она принимает \emph{тело
  загрузки}, на выходе выдает функцию-действие, которое должен
выполнить загрузочный агент.

{\emДействие} загрузочного агента это функция которая применяется к
телу агента, она выполняет некоторую полезную работу и изменяет
состояние агента. Возникающие во время выполнения действия ошибки,
непредусмотренные или возникающие по воле программиста, должны
приводить к выбрасыванию исключения.

Большинство загрузочных агентов содержат следующие ключи в своих телах:

\begin{description}
\item[:link] это самая важная часть загрузочного агента~--- ссылка
  которую загрузка будет обрабатывать и ради обработки которой она
  создавалась. Например, загрузки, которые обрабатывают прямые ссылки
  на файл просто загружают этот файл, в процессе следя за тем, чтобы
  не кончилось место на диске или не было дубликатов. Или если
  загрузка создана для обработки ссылок на пользовательские страницы
  файлообменника, то она как правило, занимается тем, что вырезает
  прямые ссылки из страницы, а затем создает и запускает новые
  загрузки для каждой прямой ссылки.

\item[:link-pattern] это неотемлемая часть всех прототипов загрузок
  и используется только в момент создания новой загрузки из
  прототипа. Содержит регулярное выражение, с которым сравнивается
  строка \texttt{line}, переданная в конструктор загрузки
  [[make-download]].

\item[:name] это имя загрузки. Обычно это имя загружаемого файла или
  заголовок страницы которую парсит высокоуровневая загрузка при
  получении прямых ссылок.

\item[:path] это директория в которую загружаются файлы.
  
\item[:program]~--- программа загрузочного агента.

\item[:precedence] это порядковый номер загрузки.

\item[:alive] определяет жива ли загрузка. Если загрузка мертва,
  то она не может выполнить никакое действие. Для проверки
  используется предикаты [[alive?]] и [[dead?]] соответственно.

\item[:failed] говорит о том, возникла ли ошибка во время выполнения
  прошлого действия (т.е. было ли брошено исключение во время
  выполнения действия). После каждого удачного действия сбрасывается
  на [[false]]. Для проверки используется предикат [[failed?]].

\item[:fail-reason] это причина провала действия агента; содержит
  исключение которое было брошено во время выполнения последнего
  действия. Селектор~--- [[fail-reason]]. Сбрасывается на [[nil]]
  после каждого удачного действия.

\item[:run-atom] принимает истинное значение, если в данный момент
  загрузочный агент выполняет некоторое действие. Для проверки
  используется предикат [[running?]].

\item[:stop-atom] принимает истинное значение, если загрузочный
  агент должен быть остановлен. В данный момент в программе никак не
  используется.

\item[:file-length-atom] содержит длину в байтах уже (частично)
  загруженного на компьютер файла, эта величина изменяется во время
  действия загрузочного агента, поэтому для хранения используется
  атом.

\item[:child] используется в высокоуровневых загрузках для хранения
  ссылки на дочерние загрузки.

\item[:max-running-downloads] определяет максимально допустимое
  количество запущенных (т.е. выполняющих некое действие) загрузок
  данного типа (т.е. работающих с определенным сервисом). Используется \emph{планировщиком загрузок} и
  указывается в прототипе загрузки если ограничение имеет смысл.
\end{description}

<<names>>=
make-download downloads-precedence-counter
@ 

<<definitions>>=
(def downloads-precedence-counter (atom 0))

(defn make-download [line & {:as opts :keys [program path name]}]
  (when-let [download-prototype (download-prototype-matching-address line)]
    (let-return
     [dload (agent
             (merge
              download-prototype
              {:precedence (swap! downloads-precedence-counter inc)
               :alive true
               :failed false
               :fail-reason nil
               :run-atom (atom false)
               :stop-atom (atom false)}
              (dissoc opts :program :path :name)
              (when (supplied program)
                (if-not (ifn? program)
                  (throw (Exception. "Program must be invokable."))
                  {:program program}))
              (when (supplied path)
                (if-let [valid-path (as-file path :directory true :writeable true)]
                  {:path valid-path}
                  (throw (Exception. "Path must be writeable directory."))))
              (when (supplied name)
                (if-not (string? name)
                  (throw (Exception. "Name must be string."))
                  {:name name}))))]
     (add-to-downloads dload))))
@  %def make-download downloads-precedence-counter

Здесь используются функции для добавления и удаления загрузок из
множества всех загрузок [[downloads*]].

<<names>>=
downloads* add-to-downloads remove-from-downloads
@ 

<<definitions>>=
(def downloads* (ref #{}))

(defn add-to-downloads [dload]
  (dosync (alter downloads* union (hash-set dload))))

(defn remove-from-downloads [dload]
  (dosync (alter downloads* difference (hash-set dload))))
@ %def downloads* add-to-downloads remove-from-downloads

Вспомогательные макросы [[with-return]] и [[let-return]] я очень часто
использую для явного указания значения, которое возвращает блок кода,
потому как большинство функций агентов \emph{обязаны} что-то
возвращать, при этом производя некоторые побочные эффекты.

<<names>>=
with-return let-return
@ 

<<definitions>>=
(defmacro with-return [expr & body]
  `(do (do ~@body)
       ~expr))

(defmacro let-return [[form val] & body]
  `(let [~form ~val]
     (with-return ~form
       (do ~@body))))
@ %def with-return let-return

Макрос [[supplied]] это просто переименованный [[and]], который я
использую для проверки переданных в функцию опциональных
ключей-аргументов.

<<names>>=
supplied
@ 

<<definitions>>=
(defalias supplied and)
@ %def supplied

Функция [[as-file]] это своеобразный швейцарский нож для работы с
файлами который я использую в основном для выяснения, существует ли
некий файл с определенными характеристиками. Например
\texttt{(as-file path :directory true :writeable true)} возвращает файл
\texttt{path} если это файл директории доступной для записи, в противном
случае он возвращает [[nil]].

Функция написана в «maybe-монадообразном стиле» характерном для кода
на Хаскелле~--- аргумент с помощью макроса-комбинатора прогоняется
через множество maybe-функций, и если на некотором шаге одна из
функций возвращает [[nil]], то и в конце возвращается [[nil]].

<<names>>=
as-file
@ 

<<definitions>>=
(defn as-file
  [arg & {:as args :keys [exists create readable writeable directory]}]
  (let [argtype (type arg)
        maybe-create
        (fn [f] 
          (when f 
            (cond (and (= create true) (not (.exists f)))
                  (let [dir (File. (.getParent f))]
                    (if-not (.exists dir)
                      (throw (new Exception
                                  "Cannot create file in nonexistant directory."))
                      (if-not (.canWrite dir)
                        (throw (new Exception
                                    "Cannot create file in nonwriteable directory."))
                        (do (.createNewFile f) f))))
                  :else f)))
        maybe-exists
        (fn [f]
          (when f
            (cond (= exists true) (when (.exists f) f)
                  (= exists false) (when-not (.exists f) f)
                  (not exists) f)))
        maybe-directory
        (fn [f]
          (when f
            (cond (= directory true) (when (.isDirectory f) f)
                  (= directory false) (when-not (.isDirectory f) f)
                  (not directory) f)))
        maybe-readable
        (fn [f]
          (when f
            (cond (= readable true) (when (.canRead f) f)
                  (= readable false) (when-not (.canRead f) f)
                  (not readable) f)))
        maybe-writeable
        (fn [f]
          (when f
            (cond (= writeable true) (when (.canWrite f) f)
                  (= writeable false) (when-not (.canWrite f) f)
                  (not writeable) f)))]

    (cond (= argtype File)
          (-> arg maybe-create maybe-exists maybe-directory maybe-readable maybe-writeable)

          (= argtype String)
          (if args
            (apply as-file (new File arg) (flatten (seq args)))
            (as-file (new File arg))))))
@ %def as-file

@ \paragraph{Прототип загрузки} это обычный хэш, он служит заготовкой
из которой затем собирается тело загрузочного агента. Прототипы
хранятся в глобальной переменной [[download-prototypes*]]~--- это атом
с хэшем в котором ключи~--- метки типов прототипов, а значения~---
сами прототипы загрузок.

Прототип загрузки определяется макросом [[def-download-prototype]],
этот макрос создают переменную, значением которой является хэш с
меткой типа унаследованной от метки \texttt{::download} в ключе
\texttt{:type} в метаданных. Диспетчеризация по типу широко
используется в мультиметодах селекторов и действий загрузок.

<<names>>=
download-prototypes* def-download-prototype
@ 

<<definitions>>=
(def download-prototypes* (atom {}))

(defmacro def-download-prototype [name body]
  `(let [name-keyword# (keyword (str *ns*) (str (quote ~name)))]
     (def ~name (with-meta ~body {:type name-keyword#}))
     (derive name-keyword# ::download)
     (swap! download-prototypes* assoc name-keyword# ~name)
     ~name))
@ %def download-prototypes* def-download-prototype

@ В качестве исходных данных в лейку передается список ссылок. Причем
ссылки с определенными адресами обрабатываются загрузками
определенного типа. Для получения прототипа загрузки, которая должна
обрабатывать данную ссылку используется функция
[[download-prototype-matching-address]]~--- она выбирает нужный
прототип сравнивая ссылку с регулярным выражением в ключе
\texttt{:link-pattern} в прототипах.

<<names>>=
download-prototype-matching-address
@ 

<<definitions>>=
(defn download-prototype-matching-address [line]
  (when-let [url (extract-url line)]
    (first (for [[download-type download-prototype] @download-prototypes*
                 :when (:link-pattern download-prototype)
                 :let [link (re-find (:link-pattern download-prototype) url)]
                 :when link]
             (assoc download-prototype :link link)))))
@ %def download-prototype-matching-address

Здесь функция [[extract-url]] вырезает из произвольной строки первый
попавшийся URL-адрес.

<<names>>=
extract-url
@ 

<<definitions>>=
(defn extract-url [line]
  (first (re-find #"((https?|ftp|file):((//)|(\\\\))+[\w\d:#@%/;$()~_?\+-=\\\.&]*)"
                  line)))
@ %def extract-url

@ \paragraph{Запуск загрузки} осуществляет метод [[run]]. Во избежание
запуска тела загрузки при работающем агенте или запуска мертвой или
остановленной загрузки перед запуском осуществляются соответствующие
проверки. На время работы агента атом \texttt{run-atom} в теле
загрузки устанавливается в значение [[true]]. Действие \texttt{action}
которое должна выполнить загрузка определяется её программой
\texttt{program} или задается явно опциональным аргументом
\texttt{:action}. Если во время выполнения действия исключений не
возникло~--- загрузка переходит в бездействующее состояние, в
противном случае исключение ловится и сохраняется в теле загрузки.

<<multimethods>>=
(defmulti run type-dispatch)
@ %def run

<<definitions>>=
(defmethod run ::download
  [{:as dload :keys [program run-atom stop-atom failed]} & {action :action}]

  (when (and (not *agent*) (running? dload))
    (throw (Exception. "Cannot run download while it is running.")))
  
  (debug "Run download " (represent dload))

  (if (or (dead? dload) (stopped? dload)) dload
      (try (reset! run-atom true)
           (let [action (or action (program dload))]
             (idle (action dload)))
           ;; (catch Error RuntimeException ...)
           (catch Throwable e (fail dload :reason e))
           (finally (reset! run-atom false)))))
@

@ Предикат [[running?]] проверяет~--- запущен ли агент?

<<multimethods>>=
(defmulti running? type-dispatch)
@ %def running?

<<definitions>>=
(defmethod running? ::download [dload]
  (deref (:run-atom dload)))
@ 

@ \paragraph{Остановка загрузки.} В этой версии программы функция
остановки загрузки не используется.

<<multimethods>>=
(defmulti stop type-dispatch)
@ %def stop

<<definitions>>=
(defmethod stop ::download [dload])
@ 

@ Предикат [[stopped?]] проверяет~--- не остановлен ли агент?

<<multimethods>>=
(defmulti stopped? type-dispatch)
@ %def stopped?

<<definitions>>=
(defmethod stopped? ::download [dload]
  (deref (:stop-atom dload)))
@ 

@ \paragraph{Базовые действия и предикаты загрузок.} Практически все
функции для работы с загрузками являются мультиметодами и
диспетчеризуются по типу тела агента функцией [[type-dispatch]].

<<names>>=
type-dispatch
@ 

<<definitions>>=
(defn type-dispatch
  ([x] (type x))
  ([x & xs] (type x)))
@ %def type-dispatch

@ Действие [[idle]] переводит агент в бездействующее состояние.

<<multimethods>>=
(defmulti idle type-dispatch)
@ %def idle

<<definitions>>=
(defmethod idle ::download [dload]
  (assoc dload :failed false :fail-reason nil))
@ 

@ Предикат [[idle?]] проверяет~--- находится ли агент в бездействующем
состоянии (то есть агент жив, не запущен, не остановлен и не ошибся
выполняя предыдущее действие)?

<<multimethods>>=
(defmulti idle? type-dispatch)
@ %def idle?

<<definitions>>=
(defmethod idle? ::download [dload]
  (and (alive? dload)
       (not (running? dload))
       (not (stopped? dload))
       (not (failed? dload))))
@ 

@ Предикат [[alive?]] проверяет~--- жив ли агент?

<<multimethods>>=
(defmulti alive? type-dispatch)
@ %def alive?

<<definitions>>=
(defmethod alive? ::download [dload]
  (:alive dload))
@ 

@ Предикат [[dead?]] проверяет~--- мертв ли агент?

<<multimethods>>=
(defmulti dead? type-dispatch)
@ %def dead?

<<definitions>>=
(defmethod dead? ::download [dload]
  (not (alive? dload)))
@ 

@ Действие [[fail]] используется для перевода агента в «ошибочное»
состояние. Оно пишет в лог об ошибке и сохраняет возникшее исключение
в теле агента.

<<multimethods>>=
(defmulti fail type-dispatch)
@ %def fail

<<definitions>>=
(defmethod fail ::download [dload & {reason :reason}]
  (error "Error " (represent dload) " reason: " reason)
  (assoc dload :failed true :fail-reason reason))
@ 

@ Предикат [[failed?]] проверяет~--- возникла ли ошибка во время
выполнения предыдущего действия?

<<multimethods>>=
(defmulti failed? type-dispatch)
@ %def failed?

<<definitions>>=
(defmethod failed? ::download [dload]
  (:failed dload))
@ 

@ Селектор [[fail-reason]] возвращает исключение которое было брошено
при возникновении ошибки в предыдущем действии.

<<multimethods>>=
(defmulti fail-reason type-dispatch)
@ %def fail-reason

<<definitions>>=
(defmethod fail-reason ::download [dload]
  (:fail-reason dload))
@ 

@ Действие [[die]] убивает агент.

<<multimethods>>=
(defmulti die type-dispatch)
@ %def die

<<definitions>>=
(defmethod die ::download [dload]
  (assoc dload :alive false))
@ 

@ Функция [[represent]] наглядно представляет агент в виде строки.

<<multimethods>>=
(defmulti represent type-dispatch)
@ %def represent

<<definitions>>=
(defmethod represent ::download [{:as dload :keys [name link]}]
  (str "<Download " (apply str (take 30 (or name link))) \>))
@ 

@ Функция [[performance]] вычисляет характеристики производительности
агента, например, процент загруженного файла, скорость загрузки и
прочее.

<<multimethods>>=
(defmulti performance type-dispatch)
@ %def performance

<<definitions>>=
(defmethod performance ::download
  [{:as dload :keys [total-file-length]}]
  (let [file-length (file-length dload)
        load-percent (when (and (number? total-file-length) (number? file-length)
                                (pos? total-file-length) (pos? file-length))
                       (int (Math/floor (* 100 (/ file-length total-file-length)))))]
    (merge {} (when load-percent {:load-percent load-percent}))))
@ 

@ Селектор [[file-length]] возвращает длину в байтах уже скачанного на
компьютер файла, если такой ключ \texttt{:file-length-atom} имеет
место быть в теле агента.

<<multimethods>>=
(defmulti file-length type-dispatch)
@ %def file-length

<<definitions>>=
(defmethod file-length ::download
  [{:as dload file-length-atom :file-length-atom}]
  (when file-length-atom
    (deref file-length-atom)))
@ 

@ \paragraph{Планировщик загрузок.} Планировщик загрузок это агент
который обеспечивает совместную работу загрузок друг с другом.

Планировщик представлен глобальной переменной [[download-scheduler*]]
в которой хранится агент, тело которого~--- хэш с набором ключей
определяющих алгоритм работы планировщика. Большая часть этих ключей
используется для отладки планировщика и загрузок. Среди них

\begin{description}
\item[:active] включает о отключает планировщик. Ключ используется для
  отладки программы.

\item[:schedule-with-callback] включает и отключает «callback» —
  отправку загрузкам специального сообщения
  [[callback-download-scheduler]] для вызова планировщика после
  завершения выполнения загрузкой действия. Ключ используется для
  отладки программы.

\item[:last-scheduled] это список загрузок которые были запущены
  последними. Изменяется после каждого запуска планировщика.

\item[:done-hook] этот ключ устанавливается перед запуском
  планировщика и содержит функцию которая вызывается если нет никаких
  загрузок которые планировщик мог бы запустить в будущем. Обычно это
  функция завершения работы программы.
\end{description}

<<names>>=
download-scheduler*
@

<<definitions>>=
(def download-scheduler*
     (agent {:active true
             :done-hook nil ;; run when there are no more scheduling job
             :schedule-with-callback true
             :last-scheduled ()}))
@ %def download-scheduler*

Основная задача планировщика~--- определить, с учетом всевозможных
ресурсных ограничений, какие загрузки нужно запустить; а затем
отправить им сообщение запуска [[run]] и сообщение
[[callback-download-scheduler]], предписывающее загрузке вызвать
планировщик после завершения её работы. Все это осуществляет
единственная функция [[schedule-downloads]]. Опциональный аргумент
{\ttfamily callback} используется агентом который запускает
планировщик для указания себя.

<<names>>=
schedule-downloads
@

<<definitions>>=
(defn schedule-downloads 
  [{:as scheduler :keys [active done-hook schedule-with-callback last-scheduled]}
   & {:keys [callback]}]

  {:pre [(agent? callback)]}

  (cond
   <<when scheduler is deactivated then then do not schedule>>
   <<when there are nothing to shcedule ever then leave>>   

   :shedule
   (let [successors <<list of downloads to launch>>]
     <<launch every download successor>>)))
@ %def schedule-downloads

\begin{enumerate}
\item Сперва планировщик проверяет, активен ли он; если нет, то на
  этом его работа завершается.

<<when scheduler is deactivated then do not schedule>>=
(not active) ;; then
(assoc scheduler :last-scheduled ())
@

\item Если нет ни одной загрузки которую когда-нибудь можно будет
  запустить~--- все они мертвы или множество загрузок [[downloads*]]
  пусто, то следует завершить работу планировщика и вызвать функцию
  done-hook, если она есть.

<<when there are nothing to shcedule ever then leave>>=
(or (not (seq @downloads*))
    (every?  (comp dead? deref) @downloads*))
(with-return (assoc scheduler :last-scheduled ())
  (when done-hook (done-hook)))
@ 

\item Составляется список загрузок для запуска~--- {\ttfamily
  successors}. Для этого множество всех загрузок [[downloads*]]
  разбивается на группы по типу; каждая группа загрузок сортируется в
  порядке появления каждой из загрузок в программе; все это
  сохраняется в хэше \texttt{groups}. Для каждой группы в
  \texttt{groups} определяются загрузки которые будут запущены; затем
  все они объединяются в один список.

<<list of downloads to launch>>=
(let [groups
      (into {} (for [[dloads-type dloads] (group-by (comp type deref) @downloads*)]
                 {dloads-type (sort-by (comp :precedence deref) dloads)}))]
(flatten
(for [[dloads-type dloads] groups
      :let [max-running-dloads ;; maximum amount of running
      ;; downloads for this type of downloads
      (:max-running-downloads (dloads-type @download-prototypes*))
      running-dloads (filter (comp running? deref) dloads)
      count-of-running-dloads (count running-dloads)
      idle-dloads (filter (comp idle? deref) dloads)
      failed-dloads (filter (comp failed? deref) dloads)
      count-of-dloads-to-launch (- max-running-dloads count-of-running-dloads)]]
  (cond
    ;; if no downloads in group then leave
    (not (seq dloads)) ()

    ;; if all downloads in group is dead then leave
    (every? (comp dead? deref) dloads) ()

    ;; if there are more running downloads then it might be for
    ;; that group then leave
    (<= count-of-dloads-to-launch 0) ()

    ;; schedule downloads from scratch
    (not callback)
    (take count-of-dloads-to-launch (concat idle-dloads failed-dloads))

    callback
    (take count-of-dloads-to-launch
          (concat idle-dloads (take-entirely-after callback failed-dloads))))))
@

\item Каждой загрузке из списка на запуск {\ttfamily successors}
  отсылается сообщение запуска [[run]] и, в зависимости от значения
  ключа {\ttfamily schedule-with-callback}, сообщение для запуска
  планировщика после того как загрузка выполнит действие.

<<launch every download successor>>=
(with-return (assoc scheduler :last-scheduled successors)
  (doseq [successor successors]
    (send-off successor run)
    (when schedule-with-callback
      (send-off successor callback-download-scheduler))))
@ 
\end{enumerate}

Функция [[callback-download-scheduler]] запускает планировщик
загрузок «от лица» загрузочного агента.

<<names>>=
callback-download-scheduler
@

<<definitions>>=
(defn callback-download-scheduler [dload]
  (with-return dload
    (when *agent*
      (send-off download-scheduler* schedule-downloads :callback *agent*))))
@ %def callback-download-scheduler

Предикат [[agent?]] проверяет, является ли его аргумент агентом.

<<names>>=
agent?
@ 

<<definitions>>=
(defn agent? [x]
  (instance? clojure.lang.Agent x))
@ %def agent?

Функции семейства \texttt{take-} выбирают элементы последовательности
перед заданным элементом [[take-before]], после заданного элемента
[[take-after]] и все элементы после и перед элементом включая и сам
элемент [[take-entirely-after]] (наивная реализация).

<<names>>=
take-after take-before take-entirely-after
@ 

<<definitions>>=
(defn take-after [item coll]
  (rest (drop-while (partial not= item) coll)))

(defn take-before [item coll]
  (take-while (partial not= item) coll))

(defn take-entirely-after [item coll]
  (let [after (take-after item coll)
        before (take-before item coll)]
    (concat after before
            (when-not (= (count before) (count coll))
              (list item)))))
@ %def take-after take-before take-entirely-after

@ \paragraph{Монитор прогресса.} 

% (declare monitor-progress)

% (declare show-progress)

% (def eighty-spaces "                                                                                ")

% (def progress-monitor* (agent {:agents #{}}))

% (defn begin-monitor-progress [{:as progress-monitor agents :agents} agnt]
%   {:pre (agent? agnt)}
%   (assoc progress-monitor :agents (union agents (hash-set agnt))))

% (defn cease-monitor-progress [{:as progress-monitor agents :agents} agnt]
%   {:pre (agent? agnt)}
%   (.print System/out (str "\r" eighty-spaces "\r"))
%   (assoc progress-monitor :agents (difference agents (hash-set agnt))))

% (defn monitor-progress []
%   (send-off progress-monitor* show-progress)
%   (release-pending-sends))

% (defmacro with-progress-monitoring [agnt & body]
%   `(let [agnt?# (agent? ~agnt)]
%      (try (when agnt?# (send-off progress-monitor* begin-monitor-progress ~agnt))
%           (do ~@body)
%           (finally (when agnt?# (send-off progress-monitor* cease-monitor-progress ~agnt))))))

% (defn show-progress [{:as progress-monitor agents :agents}]
%   (with-return progress-monitor
%     (.print System/out \return)
%     (doseq [abody (map deref agents)
%             :let [name (:name abody)
%                   name-length (if (string? name) (count name) nil)
%                   perf (performance abody)
%                   load-percent (:load-percent perf)]]
%       (.print System/out (str \[ (cond (not name) \-
%                                        (< name-length 12) name
%                                        :longer (str (.substring name 0 5) \. \.
%                                                     (.substring name (- name-length 7) name-length)))
%                               \space (or load-percent \0) \% \])))
%     (.print System/out \return)))


%%%%%%%%%%%%
%%%%%%%%%%%%
%%%%%%%%%%%%

<<leica.clj>>=
;;; -*- mode: clojure; coding: utf-8 -*-

;; Copyright (C) 2010 Roman Zaharov <zahardzhan@gmail.com>

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

(ns leica
  (:gen-class)
  (:use
   [clojure.set :only [difference union]]
   [clojure.contrib.duck-streams :only [slurp* read-lines]]
   clojure.contrib.command-line
   clojure.contrib.def
   clojure.test
       [log :only [info debug error]]
   hooks)

  (:require
   [clojure.contrib.io :as io])
  
  (:import
   (java.util Date)

   (java.net URLDecoder
             ConnectException)   

   (java.io File
            FileOutputStream
            InputStream)

   (org.apache.commons.httpclient URI
                                  HttpClient
                                  HttpStatus
                                  ConnectTimeoutException 
                                  NoHttpResponseException
                                  methods.GetMethod
                                  methods.HeadMethod
                                  params.HttpMethodParams
                                  util.EncodingUtil)))

(declare <<names>>)

<<multimethods>>

<<definitions>>
@ %language lisp

<<rest>>=
(def timeout-after-fail* 3000)
(def connection-timeout* 15000)
(def get-request-timeout* 30000)
(def head-request-timeout* 30000)
(def buffer-size* 65536)

(defn actual-file-length [file]
  (if (.exists file) (.length file) 0))


(defn files*-dsv-*-data-cod-ru-get-head [{:as dload :keys [link name]}]
  {:pre [(supplied link)]}
  (let [client (new HttpClient)
        head (new HeadMethod link)]
    (.. client getHttpConnectionManager getParams 
        (setConnectionTimeout connection-timeout*))
    (.. head getParams (setSoTimeout head-request-timeout*))
    (try (let [status (.executeMethod client head)]
           (if (= status HttpStatus/SC_OK)
             (let [content-length (.. head (getResponseHeader "Content-Length"))
                   content-disposition (.. head (getResponseHeader "Content-Disposition"))]
               (if-not (or content-length content-disposition) (die dload)
                 (let [length (Integer/parseInt (.getValue content-length))
                       filename (URLDecoder/decode (second (re-find #"; filename=\"(.*)\"" (.getValue content-disposition))))]
                   (if-not (and length filename) (die dload)
                     (assoc dload
                       :total-file-length length
                       :file-length-atom (atom 0)
                       :name (or name filename))))))
             (throw (Exception. "HEAD request failed."))))
         (finally (.releaseConnection head)))))

(defn get-file [{:as dload :keys [name path]}]
  {:pre [(supplied name path)]}
  (assoc dload :file (new File path name)))

(defn out-of-space-on-path? [{:as dload :keys [path file total-file-length]}]
  {:pre [(supplied path file total-file-length)]}
  (if (.exists file)
    (< (.getUsableSpace path) (- total-file-length (.length file)))
    (= (.getUsableSpace path) 0)))

(defn fully-loaded? [{:as dload :keys [file total-file-length]}]
  {:pre [(supplied file total-file-length)]}
  (boolean (and (.exists file) (<= total-file-length (.length file)))))

(defn begin-download
  [{:as dload :keys [name link file total-file-length file-length-atom]}]
  {:pre [(supplied name link file total-file-length)]}
  (let [client (HttpClient.)
        get (GetMethod. link)]
    (try
      (.. client getHttpConnectionManager getParams 
          (setConnectionTimeout connection-timeout*))
      (.. get getParams (setSoTimeout get-request-timeout*))
      (.setRequestHeader get "Range" (str "bytes=" (actual-file-length file) \-))
      (.executeMethod client get)
      (let [content-length (.getResponseContentLength get)]
        (cond (not content-length)
              (throw (Exception. "Cannot check file length before download."))

              (not= content-length (- total-file-length (actual-file-length file)))
              (throw (Exception. "Downloading file size mismatch."))

              :else
              (with-return dload
                (with-open [#^InputStream input (.getResponseBodyAsStream get)
                            #^FileOutputStream output (FileOutputStream. file true)]
                  (info "Begin download " name)
                  (with-progress-monitoring *agent*
                    (let [buffer (make-array Byte/TYPE buffer-size*)]
                      (loop [file-size (actual-file-length file)]
                        (let [read-size (.read input buffer)]
                          (when (pos? read-size)
                            (let [new-size (+ file-size read-size)]
                              (.write output buffer 0 read-size)
                              (reset! file-length-atom new-size)
                              (when *agent* (monitor-progress))
                              (when-not (stopped? dload)
                                (recur new-size))))))))
                  (.flush output)
                  (info "End download " name)))))
      (finally (.releaseConnection get)))))

(defn files*-dsv-*-data-cod-ru-download-program
  [{:as dload :keys [link name file path total-file-length]}]
  (cond (not link) die
        (not (and name total-file-length)) files*-dsv-*-data-cod-ru-get-head
        (not file) get-file
        (or (out-of-space-on-path? dload) (fully-loaded? dload)) die
        :requirements-ok begin-download))

(def files*-dsv-*-data-cod-ru
     {:program files*-dsv-*-data-cod-ru-download-program
      :max-running-downloads 1
      :link nil
      :name nil
      :path nil
      :file nil
      :total-file-length nil})

(def-download-prototype files3?-dsv-*-data-cod-ru
  (assoc files*-dsv-*-data-cod-ru :link-pattern #"http://files3?.dsv.*.data.cod.ru/.+"))

(def-download-prototype files2-dsv-*-data-cod-ru
  (assoc files*-dsv-*-data-cod-ru :link-pattern #"http://files2.dsv.*.data.cod.ru/.+"))

(def-download-prototype files3?-dsv-region-data-cod-ru
  (assoc files*-dsv-*-data-cod-ru :link-pattern #"http://files3?.dsv-region.data.cod.ru/.+"))

(def-download-prototype files2-dsv-region-data-cod-ru
  (assoc files*-dsv-*-data-cod-ru :link-pattern #"http://files2.dsv-region.data.cod.ru/.+"))

(defn data-cod-ru-parse-page [{:as dload :keys [link]}]
  {:pre [(supplied link)]}
  (let [client (new HttpClient)
        get (new GetMethod link)]
    (.. client getHttpConnectionManager getParams 
        (setConnectionTimeout connection-timeout*))
    (.. get getParams (setSoTimeout get-request-timeout*))
    (try (let [status (.executeMethod client get)]
           (if (= status HttpStatus/SC_OK)
             (let [child-link (re-find #"http://files[-\d\w\.]*data.cod.ru/[^\"]+"
                                       (slurp* (.getResponseBodyAsStream get)))]
               (if child-link
                 (assoc dload :child-link child-link)
                 (die dload)))
             (throw (Exception. "Fail to parse page."))))
         (finally (.releaseConnection get)))))

(defn data-cod-ru-make-child-download [{:as dload :keys [link child-link path]}]
  {:pre [(supplied link child-link path)]}
  (let [child (or (first (for [dl @downloads* :when (= child-link (:link @dl))] dl))
                  (make-download child-link :path path))]
    (if-not child
      (die dload)
      dload)))

(defn data-cod-ru-download-program [{:as dload :keys [link child-link child]}]
  (cond (not link) data-cod-ru-parse-page
        (not child) data-cod-ru-make-child-download
        :finally die))

(def-download-prototype data-cod-ru
  {:link-pattern #"http://[\w\-]*.data.cod.ru/\d+"
   :program data-cod-ru-download-program
   :link nil
   :path nil
   :child-link nil
   :child nil})


(def help* 
     "Leica -- downloader written in lisp.

Download files:

leica [keys] [file with links] [directory]")

(defn exit-program []
  (debug "Leica is done. Bye.")
  (System/exit 0))

(defn -main [& args]
  (with-command-line args help*
    [[quiet?  q? "work quietly"]
     [debug?  d? "write debug messages"]
     remaining-args]

    (let [lines-with-links
          (read-lines (some #(as-file % :readable true :directory false) remaining-args))

          workpath
          (or (some #(as-file % :writeable true :directory true) remaining-args)
              (as-file (System/getProperty "user.dir") :writeable true :directory true))]

      (when-not lines-with-links
        (info "You must specify file with links to download.")
        (exit-program))

      (when-not workpath
        (info "You must specify directory in which files will be downloaded.")
        (exit-program))

      (doseq [line lines-with-links]
        (make-download line :path workpath))

      (send-off download-scheduler* assoc :done-hook exit-program)
      (send-off download-scheduler* schedule-downloads))))
@ 

\end{document}
